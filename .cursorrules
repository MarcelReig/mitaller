# MiTaller.art - Marketplace de Artesanos de Menorca

## Contexto del Proyecto
Marketplace multi-vendor SaaS para artesanos de Menorca. Los artesanos pueden:
- Crear perfil pÃºblico con slug Ãºnico (/artistas/{slug})
- Gestionar portfolio de obras (galerÃ­a de su trabajo)
- Vender productos con Stripe Connect (comisiÃ³n 12%)
- Gestionar pedidos desde su dashboard

## Stack TecnolÃ³gico

### Backend (Django)
- Framework: Django 5.2.7 + Django REST Framework 3.16.1
- Database: PostgreSQL 15
- Auth: JWT (djangorestframework-simplejwt)
- Media: Cloudinary (implementado)
- Payments: Stripe Connect Express (implementado)
- Monitoring: Sentry (monitoreo de errores en producciÃ³n)
- Deploy: Railway

### Frontend (Next.js)
- Framework: Next.js 15.5.4 (App Router) + React 19
- Language: TypeScript (strict mode)
- Styling: Tailwind CSS 4 + shadcn/ui
- HTTP: Axios + TanStack Query
- State: Zustand (auth + cart)
- Deploy: Vercel

## Estructura del Monorepo

mitaller/
â”œâ”€â”€ backend/          # Django REST API
â”‚   â”œâ”€â”€ config/       # Settings del proyecto
â”‚   â”œâ”€â”€ accounts/     # Custom User + Auth
â”‚   â”œâ”€â”€ artisans/     # Perfiles de artesanos (antes artists)
â”‚   â”œâ”€â”€ works/        # Portfolio items
â”‚   â”œâ”€â”€ shop/         # Productos
â”‚   â”œâ”€â”€ orders/       # Pedidos
â”‚   â”œâ”€â”€ payments/     # Stripe Connect
â”‚   â””â”€â”€ admin_panel/  # Panel admin
â””â”€â”€ frontend/         # Next.js App Router
    â””â”€â”€ src/
        â”œâ”€â”€ app/      # Routes (App Router)
        â”‚   â”œâ”€â”€ (admin)/     # Panel administraciÃ³n
        â”‚   â”œâ”€â”€ (public)/    # PÃ¡ginas pÃºblicas
        â”‚   â”œâ”€â”€ (dashboard)/ # Dashboard artesano
        â”‚   â””â”€â”€ (auth)/      # Login/Registro
        â”œâ”€â”€ components/
        â”‚   â”œâ”€â”€ admin/       # Admin dashboard
        â”‚   â”œâ”€â”€ cart/        # Carrito multi-vendor
        â”‚   â”œâ”€â”€ artisans/    # Artesanos
        â”‚   â”œâ”€â”€ products/    # Tienda
        â”‚   â””â”€â”€ ...
        â”œâ”€â”€ lib/      # Utils + API client
        â”œâ”€â”€ stores/   # Zustand stores
        â””â”€â”€ types/    # TypeScript types

## Apps Django y Responsabilidades

### accounts (Auth + Users)
- Custom User model (email como username)
- Roles: ADMIN, ARTISAN, CUSTOMER
- JWT authentication (register, login, refresh, logout)
- is_approved: AprobaciÃ³n manual por admin antes de vender
- Email verification (futuro)

### artisans (Perfiles PÃºblicos) - ANTES: artists
- ArtisanProfile model (1:1 con User)
- Campos: slug, display_name, bio, avatar, cover_image, location (pueblo Menorca), craft_type
- Stripe: stripe_account_id, stripe_account_status, onboarding_completed
- URLs pÃºblicas: /api/v1/artisans/, /api/v1/artisans/{slug}/
- IMPORTANTE: Nomenclatura artisan (NO artist) en todo el cÃ³digo nuevo

### works (Portfolio)
- Work model: tÃ­tulo, descripciÃ³n, categorÃ­a, media_urls[], thumbnail_url
- ForeignKey a ArtistProfile
- display_order para drag & drop
- Solo el artesano dueÃ±o puede editar sus obras

### shop (E-commerce)
- Product model: nombre, precio, stock, thumbnail_url (Cloudinary), images (JSON)
- IntegraciÃ³n Stripe Connect: stripe_product_id, stripe_price_id
- Solo el artesano dueÃ±o puede editar sus productos

### orders (Pedidos)
- Order model: multi-vendor, status, payment_status, customer_email (guest checkout)
- OrderItem: relaciona Order con Product y Artisan (snapshot de precio para inmutabilidad)
- order_number auto-generado: ORD-YYYYMMDD-XXXXXX

### payments (Stripe Connect)
- Payment model: historial de pagos, stripe_payment_id
- Stripe Connect onboarding para artesanos
- Webhooks para sincronizaciÃ³n de estado

## Convenciones de CÃ³digo

### Python (Backend)
- Style: PEP 8 estricto
- Type hints: Usar siempre que sea posible
- Docstrings: Google style para funciones complejas
- Imports: isort con perfil "black"
- Naming:
  * Variables/funciones: snake_case
  * Clases: PascalCase
  * Constantes: UPPER_SNAKE_CASE

### TypeScript (Frontend)
- Style: Airbnb + Prettier
- Strict mode: habilitado
- Naming:
  * Variables/funciones: camelCase
  * Componentes: PascalCase
  * Constantes: UPPER_SNAKE_CASE
  * Tipos/Interfaces: PascalCase SIN prefijo I (User, Artisan, not IUser)
- Path aliases: `@/components/*`, `@/lib/*`, `@/types/*`, `@/stores/*`

### CSS (Tailwind)
- Preferir utilities de Tailwind
- Custom CSS solo cuando sea necesario (usar BEM)
- Responsive: mobile-first (sm:, md:, lg:, xl:)

## Patrones de DiseÃ±o

### Backend (Django)
- Views: Class-Based Views con ViewSets (DRF)
- Serializers: ModelSerializer con validaciones custom
- Permissions: Custom permissions (IsArtistOwner, IsVerifiedArtisan)
- URLs: Routers de DRF, versionado /api/v1/
- Queries: Usar select_related/prefetch_related para optimizar
- Transactions: Usar transaction.atomic() en operaciones crÃ­ticas

### Frontend (Next.js)
- Components: Server Components por defecto
- Client Components: Solo cuando necesites interactividad (use* hooks)
- Data fetching: Server Components cuando sea posible, TanStack Query para client
- State management:
  * Local: useState, useReducer
  * Global: Zustand (auth, cart)
  * Server: Next.js cache, TanStack Query
- Forms: React Hook Form + zod validation
- Error handling: Error boundaries + try/catch apropiados
- **Route Groups:** OrganizaciÃ³n con `(admin)`, `(dashboard)`, `(public)`, `(auth)` para layouts especÃ­ficos
  * `(admin)/` - Panel de administraciÃ³n con AdminSidebar
  * `(dashboard)/` - Dashboard del artesano con DashboardSidebar
  * `(public)/` - PÃ¡ginas pÃºblicas (artesanos, explorar, etc.)
  * `(auth)/` - Login y registro
  * Ventaja: Layouts y middleware especÃ­ficos sin afectar URLs

### Patrones Multi-Vendor

**FilosofÃ­a:** "Juntos pero no revueltos" - cada artesano mantiene su independencia

**Backend:**
- Cada artesano tiene `shipping_cost` independiente (default 5.00â‚¬)
- Productos pueden tener `pickup_available` y `pickup_instructions`
- Productos `is_featured` se muestran primero en la tienda del artesano
- Endpoint `/api/v1/artisans/{slug}/products/` para productos por artesano

**Frontend:**
- **Hooks personalizados:**
  * `useArtisanProducts(slug, filters)` - Fetch productos de un artesano
  * `useCartByArtisan()` - Agrupa items del carrito por artesano automÃ¡ticamente
  * `useMediaQuery(query)` - Detecta breakpoints para responsive UI
- **Componentes de carrito:**
  * `CartDrawer` - Drawer lateral con agrupaciÃ³n por artesano
  * `CartItemRow` - Fila de producto con +/- (debounce 500ms)
  * ActualizaciÃ³n optimista con delay de 300ms
- **AgrupaciÃ³n automÃ¡tica:**
  * CartStore almacena items planos
  * useCartByArtisan() transforma a `CartItemsByArtisan`
  * Cada artesano muestra: subtotal productos + shipping_cost + total
  * Grand total suma todos los artesanos

**Convenciones:**
- Debounce de 500ms en actualizaciÃ³n de cantidad del carrito
- Optimistic UI con delay de 300ms para mejor UX
- Shipping cost calculado por artesano, no global
- Cada pedido agrupa items por artesano para futuras split orders

## Calidad de CÃ³digo y Mejores PrÃ¡cticas

### ğŸ¯ Principios Fundamentales

**NUNCA:**
- âŒ Implementar parches temporales o "quick fixes" que oculten el problema real
- âŒ AÃ±adir excepciones especiales en cÃ³digo global (code smell)
- âŒ Crear soluciones "fire-and-forget" sin manejo de errores
- âŒ Dejar cÃ³digo espagueti o difÃ­cil de mantener
- âŒ Asumir que "funciona" es suficiente sin considerar arquitectura
- âŒ Ignorar code smells con la excusa de "hacerlo despuÃ©s"

**SIEMPRE:**
- âœ… Identificar y resolver la causa raÃ­z del problema
- âœ… Escribir cÃ³digo limpio, mantenible y escalable desde el inicio
- âœ… Seguir el orden lÃ³gico de operaciones (servidor â†’ cliente â†’ UI)
- âœ… Implementar manejo robusto de errores (try-catch-finally)
- âœ… Documentar decisiones tÃ©cnicas importantes
- âœ… Refactorizar cuando detectes un mal olor en el cÃ³digo

### ğŸ—ï¸ Arquitectura Profesional

#### 1. Flujo Correcto de Operaciones

**Ejemplo: Logout**
```typescript
// âœ… CORRECTO: Backend primero, limpieza local despuÃ©s
logout: async () => {
  try {
    // 1. Invalidar en servidor (con token vÃ¡lido)
    await backend.logout();
  } catch (error) {
    // 2. Manejo graceful si falla
    console.warn('Backend failed, continuing cleanup');
  } finally {
    // 3. Limpieza local (siempre se ejecuta)
    clearLocalState();
    // 4. UI feedback
    showToast();
    redirect();
  }
}

// âŒ INCORRECTO: Limpieza local primero
logout: () => {
  clearLocalState();  // Token eliminado
  backend.logout();   // Falla: no hay token
  redirect();         // Interceptor redirige a /login antes
}
```

**Principio:** Operaciones crÃ­ticas de servidor primero, estado local despuÃ©s.

#### 2. Manejo de Errores Robusto

**Backend (Python):**
```python
# âœ… CORRECTO: Try-except con contexto especÃ­fico
try:
    profile = ArtistProfile.objects.get(slug=slug)
    profile.update_stripe_account(account_id)
    profile.save()
except ArtistProfile.DoesNotExist:
    logger.error(f"Artist profile not found: {slug}")
    raise Http404("Perfil no encontrado")
except StripeError as e:
    logger.error(f"Stripe API error: {str(e)}")
    raise ValidationError("Error al conectar con Stripe")
except Exception as e:
    logger.critical(f"Unexpected error: {str(e)}")
    raise

# âŒ INCORRECTO: Catch genÃ©rico sin contexto
try:
    # ... cÃ³digo
except:
    pass  # Silent failure
```

**Frontend (TypeScript):**
```typescript
// âœ… CORRECTO: Manejo especÃ­fico con fallback
async function fetchArtist(slug: string): Promise<Artist> {
  try {
    const response = await api.get(`/artists/${slug}/`);
    return response.data;
  } catch (error) {
    if (error.response?.status === 404) {
      throw new NotFoundError('Artista no encontrado');
    }
    if (error.response?.status >= 500) {
      throw new ServerError('Error del servidor');
    }
    throw new NetworkError('Error de conexiÃ³n');
  }
}

// âŒ INCORRECTO: Catch sin tipar
try {
  const data = await api.get(url);
} catch (e) {
  console.log(e);  // Â¿QuÃ© hacemos con el error?
}
```

#### 3. CÃ³digo Auto-Documentado

**Usa nombres descriptivos:**
```typescript
// âœ… CORRECTO: IntenciÃ³n clara
async function invalidateUserSessionOnServer(userId: number): Promise<void> {
  await axiosInstance.post('/api/v1/auth/logout/');
}

// âŒ INCORRECTO: Nombre ambiguo
async function doLogout(): Promise<void> {
  // Â¿QuÃ© hace exactamente?
}
```

**Comentarios explican el "por quÃ©", no el "quÃ©":**
```python
# âœ… CORRECTO: Explica la decisiÃ³n
# Guardamos el thumbnail por separado para optimizar la carga inicial de la galerÃ­a
# Las imÃ¡genes completas se cargan bajo demanda (lazy loading)
thumbnail_url = cloudinary.upload(image, transformation={
    'width': 400,
    'height': 300,
    'crop': 'fill'
})

# âŒ INCORRECTO: Repite el cÃ³digo
# Subir thumbnail
thumbnail_url = cloudinary.upload(image, ...)
```

#### 4. Principio DRY pero con Sentido ComÃºn

```typescript
// âœ… CORRECTO: AbstracciÃ³n Ãºtil
function createAuthenticatedRequest(endpoint: string, data: unknown) {
  return axiosInstance.post(endpoint, data, {
    headers: { Authorization: `Bearer ${getToken()}` }
  });
}

// âŒ INCORRECTO: Sobre-abstracciÃ³n innecesaria
function get(url) { return fetch(url); }
function post(url, data) { return fetch(url, {method: 'POST', body: data}); }
// ... Mejor usar una librerÃ­a como axios
```

#### 5. Single Responsibility Principle

```python
# âœ… CORRECTO: Responsabilidades separadas
class OrderService:
    def create_order(self, cart_items: List[CartItem]) -> Order:
        order = self._build_order(cart_items)
        self._validate_stock(cart_items)
        self._process_payment(order)
        self._send_confirmation_email(order)
        return order

# âŒ INCORRECTO: FunciÃ³n monolÃ­tica
def create_order_and_do_everything(items):
    # 200 lÃ­neas de cÃ³digo mezclando validaciÃ³n, 
    # pago, emails, notificaciones, etc.
```

### ğŸš¨ Code Smells Comunes y CÃ³mo Evitarlos

#### 1. Excepciones Especiales (Ejemplo Real)

```typescript
// âŒ INCORRECTO: Parche en interceptor
if (error.response?.status === 401) {
  // ExcepciÃ³n especial para logout
  if (url.includes('/auth/logout/')) {
    return Promise.reject(error);  // Code smell
  }
  // ... resto del cÃ³digo
}

// âœ… CORRECTO: Resolver la causa raÃ­z
// Cambiar el orden en authStore.logout() para que
// llame al backend ANTES de eliminar el token
```

#### 2. Estado Temporal FrÃ¡gil

```typescript
// âŒ INCORRECTO: Confiar en sessionStorage
logout: () => {
  sessionStorage.setItem('logout_success', 'true');
  clearTokens();
  redirect('/');
}
// En home:
useEffect(() => {
  if (sessionStorage.getItem('logout_success')) {
    toast.success('...');
    sessionStorage.removeItem('logout_success');
  }
}, []);

// âœ… CORRECTO: OperaciÃ³n atÃ³mica
logout: async () => {
  await backend.logout();
  clearTokens();
  toast.success('...');
  setTimeout(() => redirect('/'), 800);
}
```

#### 3. Callbacks Hell

```typescript
// âŒ INCORRECTO: Pyramid of doom
function processOrder(orderId, callback) {
  getOrder(orderId, (order) => {
    validateStock(order, (valid) => {
      if (valid) {
        processPayment(order, (payment) => {
          sendConfirmation(order, payment, (sent) => {
            callback(null, order);
          });
        });
      }
    });
  });
}

// âœ… CORRECTO: Async/await limpio
async function processOrder(orderId: number): Promise<Order> {
  const order = await getOrder(orderId);
  const isValid = await validateStock(order);
  
  if (!isValid) throw new ValidationError('Stock insuficiente');
  
  const payment = await processPayment(order);
  await sendConfirmation(order, payment);
  
  return order;
}
```

### ğŸ“ MÃ©tricas de CÃ³digo de Calidad

**Antes de hacer commit, pregÃºntate:**

1. **Â¿Es mantenible?** Â¿Lo entenderÃ¡s en 6 meses?
2. **Â¿Es escalable?** Â¿Funciona con 1 usuario y con 10,000?
3. **Â¿Es testeable?** Â¿Puedes escribir tests fÃ¡cilmente?
4. **Â¿Es resiliente?** Â¿Maneja errores gracefully?
5. **Â¿Es limpio?** Â¿Hay code smells evidentes?

**Si la respuesta a alguna es "No", refactoriza antes de continuar.**

### ğŸ“ Ejemplo Completo: Logout Profesional

**Antes (Con problemas):**
```typescript
logout: () => {
  removeAllTokens();              // 1. Elimina tokens primero
  axiosInstance.post('/logout/'); // 2. Backend falla (401)
  window.location.href = '/';     // 3. Interceptor redirige a /login
}
```

**Problemas:**
- âŒ Orden incorrecto de operaciones
- âŒ Backend no puede invalidar token
- âŒ Interceptor causa redirect inesperado
- âŒ No hay manejo de errores
- âŒ Code smell: necesita excepciÃ³n en interceptor

**DespuÃ©s (Profesional):**
```typescript
/**
 * Cierra sesiÃ³n del usuario
 * 
 * Flujo:
 * 1. Invalida token en servidor (permite blacklist)
 * 2. Limpia estado local (garantizado con finally)
 * 3. Muestra feedback y redirige
 */
logout: async () => {
  try {
    // Backend primero (con token vÃ¡lido)
    await axiosInstance.post('/api/v1/auth/logout/');
  } catch (error) {
    // Graceful degradation si backend falla
    console.warn('Backend logout failed, continuing with local cleanup:', error);
  } finally {
    // Limpieza local (siempre se ejecuta)
    removeAllTokens();
    set({ user: null, isAuthenticated: false });
    
    // UI feedback
    toast.success('SesiÃ³n cerrada exitosamente');
    setTimeout(() => window.location.href = '/', 800);
  }
}
```

**Ventajas:**
- âœ… Orden lÃ³gico: servidor â†’ cliente â†’ UI
- âœ… Backend puede hacer blacklist
- âœ… Manejo robusto de errores
- âœ… Limpieza garantizada (finally)
- âœ… Sin code smells ni parches
- âœ… CÃ³digo auto-documentado
- âœ… Testeable y mantenible

## API Design

### Endpoints RESTful
GET    /api/artists/              # Listar artistas (pÃºblico)
GET    /api/artists/{slug}/       # Detalle artista (pÃºblico)
POST   /api/artists/              # Crear perfil (auth requerido)
PUT    /api/artists/{slug}/       # Actualizar (owner only)

GET    /api/works/                # Listar obras (pÃºblico, filtrable por artist)
POST   /api/works/                # Crear obra (artisan verified)
PUT    /api/works/{id}/           # Actualizar (owner only)
DELETE /api/works/{id}/           # Eliminar (owner only)

GET    /api/products/             # Listar productos (pÃºblico)
POST   /api/products/             # Crear producto (artisan verified)
POST   /api/orders/               # Crear orden (customer)
GET    /api/orders/me/            # Mis Ã³rdenes (auth)

### Response format
Success:
{
  "success": true,
  "data": {...},
  "message": "Success message"
}

Error:
{
  "success": false,
  "error": "Error message",
  "details": {...}
}

## Seguridad

### Backend
- CORS: Solo frontend (local + producciÃ³n)
- JWT: Access token (15min) + Refresh token (7 dÃ­as)
- Permissions: Verificar en CADA endpoint (IsAuthenticated, IsArtistOwner)
- Input validation: Serializers + custom validators
- SQL Injection: ORM previene (no raw queries sin parametrizar)
- Secrets: Siempre en .env, nunca commitear

### Frontend
- JWT: Almacenar en httpOnly cookie (preferido) o localStorage (fallback)
- CSRF: Next.js maneja automÃ¡ticamente en Server Actions
- XSS: React escapa automÃ¡ticamente, cuidado con dangerouslySetInnerHTML
- Env vars: NEXT_PUBLIC_* solo para pÃºblicas, secretas en server-side

## Testing (Fase futura)

### Backend
- Framework: pytest + pytest-django
- Coverage mÃ­nimo: 80%
- Tests crÃ­ticos: Auth, Payments, Permissions
- Fixtures: factory_boy para datos de prueba

### Frontend
- Framework: Vitest + React Testing Library
- E2E crÃ­ticos: Playwright (registro â†’ login â†’ crear producto â†’ compra)

## Git Workflow

### Commits
Conventional Commits:
- feat: Nueva feature
- fix: Bug fix
- refactor: Refactoring sin cambio funcional
- docs: DocumentaciÃ³n
- test: Tests
- chore: Tareas mantenimiento

Ejemplos:
feat(artists): add bio field to artist profile
fix(auth): resolve JWT refresh token expiry issue
refactor(shop): optimize product query with select_related

### Branches (cuando sea necesario)
- main: ProducciÃ³n estable
- develop: Desarrollo activo (por ahora trabaja directo en main)
- feature/nombre: Features nuevas (futuro)

## ğŸš¨ REGLA CRÃTICA: VerificaciÃ³n de Consistencia FE/BE

**ANTES de finalizar cualquier cambio en backend o frontend, verifica:**

### Si modificaste Backend (models.py, serializers.py, views.py):

1. **Â¿CambiÃ³ la estructura de datos?**
   - âœ… Actualiza el tipo TypeScript correspondiente en `frontend/src/types/`
   - âœ… Verifica que los campos opcionales/requeridos coincidan
   - âœ… Verifica que los tipos de datos coincidan (int â†’ number, str â†’ string)

2. **Â¿AÃ±adiste un nuevo endpoint?**
   - âœ… AÃ±ade la funciÃ³n correspondiente en `frontend/src/lib/api/*.ts`
   - âœ… Actualiza la tabla de endpoints en `docs/ai-assistants/CONTEXT_FOR_CLAUDE.md`

3. **Â¿CambiÃ³ la lÃ³gica de permisos?**
   - âœ… Verifica protecciÃ³n de rutas en `frontend/src/app/(dashboard)/**`
   - âœ… Actualiza guards si es necesario

### Si modificaste Frontend (types/, api/, components/):

1. **Â¿CambiÃ³ un tipo TypeScript?**
   - âœ… Verifica que el serializer de backend tenga los mismos campos
   - âœ… Haz un request de prueba para confirmar la estructura

2. **Â¿AÃ±adiste un nuevo campo en un form?**
   - âœ… Verifica que el serializer backend acepte ese campo
   - âœ… Verifica validaciones en ambos lados

### Errores Comunes a Prevenir:

âŒ **NO hacer:**
- AÃ±adir campo en backend pero olvidar el tipo en frontend
- Crear endpoint nuevo sin API service
- Cambiar tipo de dato (int â†’ string) sin actualizar el otro lado
- Hacer campo opcional en un lado pero requerido en el otro

âœ… **SÃ hacer:**
- Cambiar backend Y frontend en el mismo commit
- Verificar tipos despuÃ©s de cada cambio de serializer
- Probar la integraciÃ³n completa FE/BE antes de commitear

---

## Reglas de GeneraciÃ³n de CÃ³digo

Cuando generes cÃ³digo, SIEMPRE:

1. **Resuelve la causa raÃ­z, no los sÃ­ntomas**
   - âŒ No aÃ±adas excepciones especiales o parches temporales
   - âœ… Identifica por quÃ© ocurre el problema y arrÃ©glalo en origen
   - Si algo requiere una "excepciÃ³n especial", el diseÃ±o estÃ¡ mal

2. **Sigue el orden lÃ³gico de operaciones**
   - Servidor primero (invalidar, guardar, actualizar)
   - Cliente despuÃ©s (estado local, cache)
   - UI al final (feedback, redirects)

3. **Maneja errores de forma robusta**
   - Backend: try/except especÃ­ficos con logging contextual
   - Frontend: try-catch-finally con graceful degradation
   - Nunca silenciar errores (catch sin manejo)
   - Logs Ãºtiles: quÃ© fallÃ³, por quÃ©, dÃ³nde

4. **Escribe cÃ³digo mantenible desde el inicio**
   - PregÃºntate: Â¿Lo entenderÃ© en 6 meses?
   - Refactoriza cuando detectes code smells
   - Nombres descriptivos > comentarios explicativos
   - Funciones pequeÃ±as con responsabilidad Ãºnica

5. **Explica decisiones tÃ©cnicas importantes**
   - Â¿Por quÃ© elegiste este approach?
   - Â¿QuÃ© alternativas consideraste?
   - Â¿QuÃ© trade-offs tiene?

6. **Incluye comentarios para el "por quÃ©", no el "quÃ©"**
   ```python
   # âœ… BIEN: Explica la decisiÃ³n de negocio
   # Guardamos thumbnail separado para optimizar carga inicial
   thumbnail_url = cloudinary.upload(...)
   
   # âŒ MAL: Repite lo que dice el cÃ³digo
   # Subir imagen a cloudinary
   thumbnail_url = cloudinary.upload(...)
   ```

7. **Valida inputs y outputs**
   - Backend: Serializers + custom validators
   - Frontend: zod schemas + type guards
   - Nunca confÃ­es en datos externos

8. **Usa type hints y tipos siempre**
   ```python
   # Python
   def create_artist_profile(user: User, data: dict) -> ArtistProfile:
   ```
   ```typescript
   // TypeScript
   function createOrder(items: ICartItem[]): Promise<IOrder>
   ```

9. **Verifica que el cÃ³digo sea:**
   - âœ… Mantenible (legible en 6 meses)
   - âœ… Escalable (funciona con 1 y 10,000 usuarios)
   - âœ… Testeable (fÃ¡cil escribir tests)
   - âœ… Resiliente (maneja errores gracefully)
   - âœ… Limpio (sin code smells)

10. **Sigue las convenciones del proyecto**
    - Naming, estructura, patterns
    - Consulta secciÃ³n "Calidad de CÃ³digo" arriba

## DocumentaciÃ³n

### Estructura (3 niveles)

- `docs/` - General (arquitectura, auth, troubleshooting)
- `backend/docs/modules/{app}/` - Backend especÃ­fico
- `frontend/docs/` - Frontend especÃ­fico

### CuÃ¡ndo Documentar

**SÃ documenta:**
- Feature compleja (>1h) â†’ Usa `docs/.templates/feature-template.md`
- Bug resuelto (>1h) â†’ Usa `docs/.templates/troubleshooting-template.md`
- Cambio arquitectÃ³nico o nueva integraciÃ³n

**NO documenta:**
- CRUD simple, cambios UI menores, typos

### âš ï¸ REGLA CRÃTICA: MantÃ©n Docs Actualizadas

**SIEMPRE:**
1. Si cambias cÃ³digo, actualiza docs relacionadas INMEDIATAMENTE
2. Busca refs: `grep -r "tu cambio" docs/`
3. Actualiza ejemplos de cÃ³digo y fechas
4. Nunca marques como "desactualizado", actualiza directamente

**Por quÃ©:** Docs desactualizadas son peor que no tener docs

## Contexto de Negocio (NO OLVIDAR)

- **Nomenclatura:** SIEMPRE usar "artisan" / "artesano" (NUNCA "artist" / "artista")
  * URLs: `/artesanos/{slug}` (espaÃ±ol)
  * Modelos: `ArtisanProfile` (NO `ArtistProfile`)
  * Tipos: `Artisan` (NO `Artist`)
  * RazÃ³n: Enfoque en artesanÃ­a tradicional menorquina, no arte contemporÃ¡neo
- ComisiÃ³n: 10% fija en MVP (configurable en settings.py)
- VerificaciÃ³n: Manual por admin (is_approved: False â†’ True)
- Compradores: Guest checkout (sin registro), solo email y datos de envÃ­o
- MVP Scope: Auth + Artesanos + Portfolio + Shop + Pagos (âœ… implementado)
- Pendiente: Sistema de reviews, mapa interactivo, eventos/talleres
- Target: 10-15 artesanos piloto en Menorca

---

## ğŸ—ï¸ ARQUITECTURA DEL MONOREPO - REGLAS ESENCIALES

### CaracterÃ­sticas Clave

- **Monorepo manual** (sin Turborepo/Nx) - Backend Django + Frontend Next.js separados
- **ComunicaciÃ³n:** REST API (`/api/v1/`) con JWT
- **Deploy separado:** Railway (backend) + Vercel (frontend)
- **Auth:** JWT con refresh token automÃ¡tico (cookies, NO localStorage)
- **ImÃ¡genes:** Cloudinary signed uploads (cliente sube directo, Django genera signature)

### ğŸ¯ Decisiones ArquitectÃ³nicas (resumen)

1. **NO Turborepo/Nx** - Backend Python, Frontend Node, tecnologÃ­as diferentes, deploy separado
2. **REST > GraphQL** - DRF estÃ¡ndar Django, simple debuggear, HTTP caching out-of-the-box
3. **Tipos manuales > Codegen** - Control total, sin dependencias, requiere verificaciÃ³n semanal
4. **Deploy separado** - Railway (BE) + Vercel (FE), escalabilidad independiente
5. **Cloudinary signed uploads** - Cliente sube directo, Django solo genera signature 1h

**ğŸ“– Ver detalles completos:** `docs/ai-assistants/CONTEXT_FOR_CLAUDE.md` â†’ SecciÃ³n "Arquitectura del Monorepo"

### âš ï¸ CHECKLIST SEMANAL: Consistencia Frontend â†” Backend

**CRÃTICO:** Cuando cambies cÃ³digo en backend o frontend, verifica:

#### 1. Modelos â†’ Serializers â†’ Tipos

```bash
# Â¿CambiÃ³ el modelo User/Artisan/Product/Order?
# â†’ Verifica que el Serializer tenga los mismos campos
# â†’ Verifica que el tipo TypeScript coincida EXACTAMENTE
# â†’ Si aÃ±ades campo en backend, aÃ±Ã¡delo en frontend INMEDIATAMENTE
```

**Ejemplo:**
```python
# backend/accounts/serializers.py
class UserSerializer(serializers.ModelSerializer):
    class Meta:
        fields = ('id', 'email', 'username', 'role', 'can_sell')
```

```typescript
// frontend/src/types/user.ts
export interface User {
  id: number;
  email: string;
  username: string;
  role: UserRole;
  can_sell?: boolean;
}
```

**âœ… Campos deben coincidir 1:1**

#### 2. Endpoints â†’ API Services

```bash
# Â¿AÃ±adiste POST /api/v1/products/?
# â†’ AÃ±ade createProduct() en frontend/src/lib/api/products.ts
# â†’ Documenta en tabla de endpoints
```

#### 3. Permisos â†’ Frontend Guards

```bash
# Â¿CambiÃ³ la lÃ³gica de can_sell en backend?
# â†’ Verifica protecciÃ³n de rutas en frontend/src/app/(dashboard)/**
# â†’ Actualiza authStore si es necesario
```

#### 4. Errores Comunes a Detectar

**âŒ NUNCA:**
- Campo nuevo en serializer pero NO en tipo TypeScript
- Endpoint nuevo en backend pero NO en API service del frontend
- Tipo de dato diferente (backend: `int` vs frontend: `string`)
- Campo opcional en backend pero requerido en frontend (o viceversa)
- Enum values diferentes entre backend y frontend

**âœ… SIEMPRE:**
- Verificar tipos despuÃ©s de cambiar serializer
- AÃ±adir endpoint al API service cuando crees nueva vista
- Mantener misma estructura de datos en FE y BE
- Usar snake_case en backend, camelCase en frontend (consistente en cada lado)

### ğŸ“¦ Archivos que Cambian Juntos (recordatorio rÃ¡pido)

| Backend | Frontend | AcciÃ³n |
|---------|----------|--------|
| `*/models.py` â†’ `*/serializers.py` | `types/*.ts` | Actualizar tipos TypeScript |
| `*/views.py` â†’ `*/urls.py` | `lib/api/*.ts` | AÃ±adir API service |
| `settings.py` | `.env.local` | Sincronizar env vars |

### ğŸš€ Comandos Desarrollo

```bash
# Terminal 1: Backend
cd backend && python manage.py runserver  # :8000

# Terminal 2: Frontend
cd frontend && npm run dev  # :3000
```

---

## ğŸ“– REFERENCIA: docs/ai-assistants/CONTEXT_FOR_CLAUDE.md

**Para informaciÃ³n detallada que no necesitas en cada sesiÃ³n, consulta:**

`docs/ai-assistants/CONTEXT_FOR_CLAUDE.md` contiene:
- ğŸ—ï¸ Ãrbol completo del monorepo (ASCII, 2 niveles)
- ğŸ”„ Diagrama de flujo JWT completo con refresh token
- ğŸ“Š Tabla de endpoints (mapeo FE â†” BE)
- âœ… VerificaciÃ³n de tipos (backend serializers vs frontend types)
- ğŸš€ Estrategia de deploy (Railway + Vercel, env vars)
- ğŸ¯ 10 decisiones arquitectÃ³nicas (detalladas con trade-offs)
- ğŸ—„ï¸ Modelo de datos completo (relaciones, convenciones)
- ğŸ“ 3 flujos crÃ­ticos (registro, compra, upload Cloudinary)

**CuÃ¡ndo leer docs/ai-assistants/CONTEXT_FOR_CLAUDE.md:**
- Necesitas entender arquitectura profunda
- Vas a tomar decisiones arquitectÃ³nicas
- Necesitas ver todos los endpoints
- Quieres verificar tipos especÃ­ficos
- Necesitas contexto para Claude Web

---

## Referencias

- Marina (proyecto anterior): /marina-backend, /marina-frontend
  â†’ Reutilizar lÃ³gica de upload Cloudinary, drag & drop, auth flow
- Django Docs: https://docs.djangoproject.com/
- DRF Docs: https://www.django-rest-framework.org/
- Next.js Docs: https://nextjs.org/docs
- shadcn/ui: https://ui.shadcn.com/

## Notas Importantes

- Este es un MONOREPO: backend y frontend en el mismo repo
- Deploy separado: Railway (backend) + Vercel (frontend)
- Cursor puede ver TODO el contexto del proyecto
- Al responder, pregunta si algo no estÃ¡ claro antes de asumir