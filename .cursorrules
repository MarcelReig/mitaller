# MiTaller.art - Marketplace de Artesanos de Menorca

## Contexto del Proyecto
Marketplace multi-vendor SaaS para artesanos de Menorca. Los artesanos pueden:
- Crear perfil público con slug único (/artistas/{slug})
- Gestionar portfolio de obras (galería de su trabajo)
- Vender productos con Stripe Connect (comisión 12%)
- Gestionar pedidos desde su dashboard

## Stack Tecnológico

### Backend (Django)
- Framework: Django 5.0 + Django REST Framework
- Database: PostgreSQL 15
- Auth: JWT (djangorestframework-simplejwt)
- Media: Cloudinary (futuro)
- Payments: Stripe Connect Express (futuro)
- Deploy: Railway

### Frontend (Next.js)
- Framework: Next.js 14 (App Router)
- Language: TypeScript (strict mode)
- Styling: Tailwind CSS + shadcn/ui
- HTTP: Axios + TanStack Query
- State: Zustand (auth + global state)
- Deploy: Vercel

## Estructura del Monorepo

mitaller/
├── backend/          # Django REST API
│   ├── config/       # Settings del proyecto
│   ├── accounts/     # Custom User + Auth
│   ├── artists/      # Perfiles de artesanos
│   ├── works/        # Portfolio items
│   └── shop/         # Productos + Orders
└── frontend/         # Next.js App Router
    └── src/
        ├── app/      # Routes (App Router)
        ├── components/
        ├── lib/      # Utils + API client
        └── stores/   # Zustand stores

## Apps Django y Responsabilidades

### accounts (Auth + Users)
- Custom User model (email como username)
- Roles: CUSTOMER, ARTISAN_PENDING, ARTISAN_VERIFIED, ADMIN
- JWT authentication (register, login, refresh, logout)
- Email verification (futuro)

### artists (Perfiles Públicos)
- ArtistProfile model (1:1 con User)
- Campos: slug, display_name, bio, avatar, location (pueblo Menorca), craft_type
- Stripe: stripe_account_id, onboarding_completed (futuro)
- URLs públicas: /api/artists/, /api/artists/{slug}/

### works (Portfolio)
- Work model: título, descripción, categoría, media_urls[], thumbnail_url
- ForeignKey a ArtistProfile
- display_order para drag & drop
- Solo el artesano dueño puede editar sus obras

### shop (E-commerce)
- Product model: nombre, precio, stock, imagen, shipping_options
- Order model: multi-vendor, status, stripe_session_id
- OrderItem: relaciona Order con Product y ArtistProfile (para comisiones)
- Solo el artesano dueño puede editar sus productos

## Convenciones de Código

### Python (Backend)
- Style: PEP 8 estricto
- Type hints: Usar siempre que sea posible
- Docstrings: Google style para funciones complejas
- Imports: isort con perfil "black"
- Naming:
  * Variables/funciones: snake_case
  * Clases: PascalCase
  * Constantes: UPPER_SNAKE_CASE

### TypeScript (Frontend)
- Style: Airbnb + Prettier
- Strict mode: habilitado
- Naming:
  * Variables/funciones: camelCase
  * Componentes: PascalCase
  * Constantes: UPPER_SNAKE_CASE
  * Tipos/Interfaces: PascalCase con prefijo I (IUser, IArtist)

### CSS (Tailwind)
- Preferir utilities de Tailwind
- Custom CSS solo cuando sea necesario (usar BEM)
- Responsive: mobile-first (sm:, md:, lg:, xl:)

## Patrones de Diseño

### Backend (Django)
- Views: Class-Based Views con ViewSets (DRF)
- Serializers: ModelSerializer con validaciones custom
- Permissions: Custom permissions (IsArtistOwner, IsVerifiedArtisan)
- URLs: Routers de DRF, versionado /api/v1/
- Queries: Usar select_related/prefetch_related para optimizar
- Transactions: Usar transaction.atomic() en operaciones críticas

### Frontend (Next.js)
- Components: Server Components por defecto
- Client Components: Solo cuando necesites interactividad (use* hooks)
- Data fetching: Server Components cuando sea posible, TanStack Query para client
- State management:
  * Local: useState, useReducer
  * Global: Zustand (auth, cart)
  * Server: Next.js cache, TanStack Query
- Forms: React Hook Form + zod validation
- Error handling: Error boundaries + try/catch apropiados

## API Design

### Endpoints RESTful
GET    /api/artists/              # Listar artistas (público)
GET    /api/artists/{slug}/       # Detalle artista (público)
POST   /api/artists/              # Crear perfil (auth requerido)
PUT    /api/artists/{slug}/       # Actualizar (owner only)

GET    /api/works/                # Listar obras (público, filtrable por artist)
POST   /api/works/                # Crear obra (artisan verified)
PUT    /api/works/{id}/           # Actualizar (owner only)
DELETE /api/works/{id}/           # Eliminar (owner only)

GET    /api/products/             # Listar productos (público)
POST   /api/products/             # Crear producto (artisan verified)
POST   /api/orders/               # Crear orden (customer)
GET    /api/orders/me/            # Mis órdenes (auth)

### Response format
Success:
{
  "success": true,
  "data": {...},
  "message": "Success message"
}

Error:
{
  "success": false,
  "error": "Error message",
  "details": {...}
}

## Seguridad

### Backend
- CORS: Solo frontend (local + producción)
- JWT: Access token (15min) + Refresh token (7 días)
- Permissions: Verificar en CADA endpoint (IsAuthenticated, IsArtistOwner)
- Input validation: Serializers + custom validators
- SQL Injection: ORM previene (no raw queries sin parametrizar)
- Secrets: Siempre en .env, nunca commitear

### Frontend
- JWT: Almacenar en httpOnly cookie (preferido) o localStorage (fallback)
- CSRF: Next.js maneja automáticamente en Server Actions
- XSS: React escapa automáticamente, cuidado con dangerouslySetInnerHTML
- Env vars: NEXT_PUBLIC_* solo para públicas, secretas en server-side

## Testing (Fase futura)

### Backend
- Framework: pytest + pytest-django
- Coverage mínimo: 80%
- Tests críticos: Auth, Payments, Permissions
- Fixtures: factory_boy para datos de prueba

### Frontend
- Framework: Vitest + React Testing Library
- E2E críticos: Playwright (registro → login → crear producto → compra)

## Git Workflow

### Commits
Conventional Commits:
- feat: Nueva feature
- fix: Bug fix
- refactor: Refactoring sin cambio funcional
- docs: Documentación
- test: Tests
- chore: Tareas mantenimiento

Ejemplos:
feat(artists): add bio field to artist profile
fix(auth): resolve JWT refresh token expiry issue
refactor(shop): optimize product query with select_related

### Branches (cuando sea necesario)
- main: Producción estable
- develop: Desarrollo activo (por ahora trabaja directo en main)
- feature/nombre: Features nuevas (futuro)

## Reglas de Generación de Código

Cuando generes código, SIEMPRE:

1. Explica decisiones técnicas importantes
   - ¿Por qué elegiste este approach?
   - ¿Hay alternativas?

2. Incluye comentarios para lógica compleja
   # Calculate artist payout after 12% platform commission
   artist_payout = price * Decimal('0.88')

3. Maneja errores apropiadamente
   - Backend: try/except con logs
   - Frontend: Error boundaries + user-friendly messages

4. Valida inputs
   - Backend: Serializers + custom validators
   - Frontend: zod schemas

5. Usa type hints y tipos
   Python: def create_artist_profile(user: User, data: dict) -> ArtistProfile:
   TypeScript: function createOrder(items: ICartItem[]): Promise<IOrder>

6. Sigue las convenciones arriba
   - Naming, estructura, patterns

## Documentación

### Estructura de Documentación
El proyecto tiene 3 niveles de documentación organizados:

```
mitaller/
├── docs/              # Documentación general del proyecto
│   ├── README.md      # Índice principal
│   ├── architecture/  # Diseño técnico, conceptos
│   ├── auth/          # Sistema de autenticación
│   ├── deployment/    # Deploy, dependencias
│   ├── phases/        # Fases del proyecto
│   ├── troubleshooting/ # Problemas resueltos
│   └── .templates/    # Plantillas
├── backend/docs/      # Documentación específica del backend
│   ├── README.md      # Índice backend
│   ├── modules/       # Por app Django (accounts, artists, etc.)
│   └── config/        # Configuración backend
└── frontend/docs/     # Documentación específica del frontend
    ├── README.md      # Índice frontend
    ├── auth/          # Auth frontend
    ├── config/        # Env vars, setup
    ├── guides/        # Hooks, types, layouts
    ├── features/      # Features específicas
    └── placeholders/  # Sistema de placeholders
```

### Cuándo Documentar

**SIEMPRE documenta:**
- Nueva feature compleja (usa plantilla `feature-template.md`)
- Problema resuelto que tomó >1h (usa plantilla `troubleshooting-template.md`)
- Cambio arquitectónico significativo
- Nueva integración (Stripe, Cloudinary, etc.)
- Proceso de setup no obvio

**NO hace falta documentar:**
- CRUD simple siguiendo patrones existentes
- Cambios menores de UI
- Fixes triviales de typos o estilos

### Dónde Colocar la Documentación

**Documentación General** → `docs/`:
- Arquitectura del sistema completo
- Decisiones de diseño transversales
- Autenticación (flujo completo backend+frontend)
- Troubleshooting general

**Backend específico** → `backend/docs/modules/{app}/`:
- Guías de API de un módulo Django
- Modelos complejos con lógica de negocio
- Integraciones backend (Stripe Connect)
- Cada app mantiene su README.md en la carpeta de la app

**Frontend específico** → `frontend/docs/`:
- Hooks personalizados complejos
- Componentes reutilizables avanzados
- Guías de tipos TypeScript
- Setup de herramientas (Cloudinary upload)

### Formato de Documentación

**Estructura de archivo:**
```markdown
# Título Descriptivo

> Breve descripción (1-2 líneas)

## 📋 Contexto
¿Qué problema resuelve? ¿Por qué es necesario?

## 🛠️ Implementación
### Backend (si aplica)
- Código clave
- Endpoints afectados

### Frontend (si aplica)
- Componentes principales
- Hooks/utils usados

## ✅ Uso
Ejemplos prácticos de cómo usar

## 🐛 Known Issues / Limitaciones
(si hay)

---
**Autor**: [nombre]  
**Fecha**: [YYYY-MM-DD]
```

**Estilo:**
- Emojis para secciones (📋 📊 🛠️ ✅ 🐛 ⚡)
- Code blocks con sintaxis highlight
- Enlaces internos a otros docs cuando sea relevante
- Screenshots solo si aportan valor real

### Plantillas Disponibles

**Para nueva feature:**
```bash
cp docs/.templates/feature-template.md docs/features/mi-feature.md
# O en módulo específico:
cp docs/.templates/feature-template.md backend/docs/modules/payments/feature-name.md
```

**Para problema resuelto:**
```bash
cp docs/.templates/troubleshooting-template.md docs/troubleshooting/problema-xyz.md
```

### Ejemplo de Cuándo Usar Cada Ubicación

**Caso 1: Nueva feature de galería con lightbox**
- Afecta solo frontend
- **Ubicación**: `frontend/docs/features/GALERIA_LIGHTBOX.md`
- **Incluir**: Componentes, hooks, guía de uso

**Caso 2: Integración Stripe Connect**
- Afecta backend principalmente
- **Ubicación**: `backend/docs/modules/payments/STRIPE_CONNECT_GUIDE.md`
- **Incluir**: Webhooks, API calls, testing en dev

**Caso 3: Sistema de autenticación JWT completo**
- Afecta backend + frontend
- **Ubicación**: `docs/auth/SISTEMA_AUTENTICACION.md`
- **Incluir**: Flujo completo, decisiones arquitectónicas

**Caso 4: Bug de logout que borraba tokens incorrectamente**
- Problema específico resuelto
- **Ubicación**: `docs/troubleshooting/PROBLEMA_LOGOUT.md`
- **Incluir**: Síntomas, causa raíz, solución, verificación

### Reglas para el AI

Cuando generes código que requiera documentación:

1. **Pregunta dónde documentar** si no está claro
2. **Usa las plantillas** apropiadas
3. **Actualiza índices** (README.md de cada docs/)
4. **Enlaza desde el código** si es relevante:
   ```python
   # Ver documentación completa en backend/docs/modules/payments/STRIPE_CONNECT_GUIDE.md
   ```
5. **Mantén la documentación cerca del código conceptualmente**
   - Feature de artists → backend/docs/modules/artists/
   - No todo en docs/ raíz

### ⚠️ REGLA CRÍTICA: Documentación Siempre Actualizada

**NUNCA dejes documentación desactualizada:**

1. **Cuando cambies código, actualiza la documentación relacionada INMEDIATAMENTE**
   - Si cambias una API, actualiza su documentación
   - Si corriges un bug documentado, actualiza el troubleshooting
   - Si refactorizas, actualiza los ejemplos de código

2. **NO marques documentos como "desactualizados" o "obsoletos"**
   - ❌ MAL: Añadir "⚠️ DOCUMENTO DESACTUALIZADO"
   - ✅ BIEN: Actualizar el contenido directamente
   - Si necesitas refactorizar documentación, hazlo, no la marques

3. **Busca documentos relacionados antes de terminar**
   - Usa grep para buscar referencias al código que cambias
   - Ejemplo: Si cambias signed uploads, busca "signed upload" en docs/
   - Actualiza TODOS los documentos que mencionen la feature

4. **Verifica la consistencia de ejemplos de código**
   - Los code snippets deben reflejar el código actual
   - Las configuraciones deben estar actualizadas
   - Los comandos deben ser los correctos

5. **Actualiza fechas y versiones**
   - Cambia "Última actualización" al final de los docs
   - Si cambias significativamente un doc, actualiza su fecha

**Ejemplo de workflow correcto:**

```
1. Usuario pide cambiar código X
2. Haces el cambio en el código
3. ANTES de terminar, buscas: grep -r "código X" docs/
4. Actualizas TODOS los docs que mencionan X
5. Verificas que los ejemplos funcionen
6. Actualizas fechas
7. ENTONCES terminas la tarea
```

**Por qué es crítico:**
- Documentación desactualizada es PEOR que no tener documentación
- Causa confusión y pérdida de tiempo
- Rompe la confianza en la documentación
- El proyecto pierde su "fuente de verdad"

## Contexto de Negocio (NO OLVIDAR)

- Comisión: 12% fija en MVP (futuro: 15% free, 8% pro + 20€/mes)
- Verificación: Manual por admin (cambiar role PENDING → VERIFIED)
- Envíos: Cada artesano define precios (local/península/internacional)
- MVP Scope: Auth + Artistas + Portfolio + Shop + Pagos (sin reviews, mapa, eventos)
- Target: 10-15 artesanos piloto en 12 semanas

## Referencias

- Marina (proyecto anterior): /marina-backend, /marina-frontend
  → Reutilizar lógica de upload Cloudinary, drag & drop, auth flow
- Django Docs: https://docs.djangoproject.com/
- DRF Docs: https://www.django-rest-framework.org/
- Next.js Docs: https://nextjs.org/docs
- shadcn/ui: https://ui.shadcn.com/

## Notas Importantes

- Este es un MONOREPO: backend y frontend en el mismo repo
- Deploy separado: Railway (backend) + Vercel (frontend)
- Cursor puede ver TODO el contexto del proyecto
- Al responder, pregunta si algo no está claro antes de asumir